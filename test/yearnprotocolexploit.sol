pragma solidity ^0.8.20;
import "forge-std/Test.sol";
interface IYFIRewardPool {
    function last_token_time() external view returns (uint256);
    function token_last_balance() external view returns (uint256);
    function tokens_per_week(uint256) external view returns (uint256);
    function checkpoint_token() external;
    function token() external view returns (address);
}
interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}
contract CheckpointTokenLossTest is Test {
    address constant REWARD_POOL = 0xb287a1964AEE422911c7b8409f5E5A273c1412fA;
    uint256 constant WEEK = 7 days;
    IYFIRewardPool pool;
    IERC20 yfi;
    function setUp() public {
        string memory rpc = vm.envString("MAINNET_RPC_URL");
        vm.createSelectFork(rpc);
        pool = IYFIRewardPool(REWARD_POOL);
        yfi = IERC20(pool.token());
    }
    function testCheckpointTokenLosesRewardsAfterLongInactivity() public {
        // 1. clean state: account all existing rewards
        uint256 lastTokenTime = pool.last_token_time();
        // move a bit forward in time so checkpoint_token() can be called
        // TOKEN_CHECKPOINT_DEADLINE = 86400 (1 day), so +2 days is safe
        uint256 t1 = lastTokenTime + 2 days;
        vm.warp(t1);
        // this will run _checkpoint_token and make token_last_balance == balanceOf(pool)
        pool.checkpoint_token();
        lastTokenTime = pool.last_token_time();
        uint256 startWeek = (lastTokenTime / WEEK) * WEEK;
        // 2. warp > 40 weeks ahead (trigger the 40-iteration limit)
        uint256 gap = 41 * WEEK; // > 40 weeks so the bug MUST trigger
        uint256 t2 = lastTokenTime + gap;
        vm.warp(t2);
        // 3. snapshot tokens_per_week[*] before adding new tokens
        uint256 numWeeks = 60; // plenty to cover all affected weeks
        uint256[] memory weekTimes = new uint256[](numWeeks);
        uint256[] memory before = new uint256[](numWeeks);
        for (uint256 i; i < numWeeks; ++i) {
            uint256 w = startWeek + i * WEEK;
            weekTimes[i] = w;
            before[i] = pool.tokens_per_week(w);
        }
        // 4. added NEW YFI to the pool (this becomes to_distribute)
        uint256 deposit = 100 ether; // 100 YFI (18 decimals)
        // Foundry's cheatcode: mint YFI to this test contract on the fork
        deal(address(yfi), address(this), deposit);
        // Send it directly to the reward pool (no burn(), as in your report)
        yfi.transfer(REWARD_POOL, deposit);
        uint256 balanceBefore = yfi.balanceOf(REWARD_POOL);
        uint256 tokenLastBefore = pool.token_last_balance();
        uint256 toDistribute = balanceBefore - tokenLastBefore;
        // sanity check: our deposit should be exactly the undistributed amount
        assertEq(
            toDistribute,
            deposit,
            "Unexpected toDistribute"
        );
        // 5. run the vulnerable checkpoint
        pool.checkpoint_token();
        // 6. how much was ACTUALLY written to tokens_per_week?
        uint256[] memory after_ = new uint256[](numWeeks);
        uint256 distributed;
        for (uint256 i; i < numWeeks; ++i) {
            after_[i] = pool.tokens_per_week(weekTimes[i]);
            distributed += (after_[i] - before[i]);
        }
        emit log_named_uint("toDistribute", toDistribute);
        emit log_named_uint("actuallyDistributed", distributed);
        // BUG: distributed < toDistribute
        // i.e. some YFI was never assigned to any week and is now stuck
        assertLt(
            distributed,
            toDistribute,
            "all tokens were distributed;"
        );
        uint256 lost = toDistribute - distributed;
        emit log_named_uint("lostForever", lost);
        // 7. Show the loss is permanent: later checkpoint does NOT recover it
        uint256 lastTokenTime2 = pool.last_token_time();
        vm.warp(lastTokenTime2 + 2 days); // ensure we can call checkpoint_token again
        // Snapshot again
        uint256[] memory before2 = new uint256[](numWeeks);
        for (uint256 i; i < numWeeks; ++i) {
            before2[i] = pool.tokens_per_week(weekTimes[i]);
        }
        pool.checkpoint_token();
        uint256[] memory after2 = new uint256[](numWeeks);
        uint256 distributed2;
        for (uint256 i; i < numWeeks; ++i) {
            after2[i] = pool.tokens_per_week(weekTimes[i]);
            distributed2 += (after2[i] - before2[i]);
        }
        assertEq(distributed2, 0, "Unexpected extra distribution on second checkpoint");
        // meaning all tokens (including the lost ones) are considered "accounted"
        uint256 finalBalance = yfi.balanceOf(REWARD_POOL);
        uint256 finalTokenLastBalance = pool.token_last_balance();
        assertEq(finalBalance, finalTokenLastBalance, "Accounting mismatch after checkpoints");
    }
}
